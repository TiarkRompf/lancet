// constants: scala.collection.Seq$@30176ce7,public final native java.lang.Class java.lang.Object.getClass(),public abstract java.lang.reflect.Method scala.runtime.MethodCache.find(java.lang.Class),public boolean java.lang.reflect.AccessibleObject.isAccessible(),public void java.lang.reflect.AccessibleObject.setAccessible(boolean) throws java.lang.SecurityException,public abstract scala.runtime.MethodCache scala.runtime.MethodCache.add(java.lang.Class,java.lang.reflect.Method)
class Generated0(CONST_0: scala.collection.Seq$,CONST_1: java.lang.reflect.Method,CONST_2: java.lang.reflect.Method,CONST_3: java.lang.reflect.Method,CONST_4: java.lang.reflect.Method,CONST_5: java.lang.reflect.Method) extends (scala.collection.Seq[_]=>scala.collection.Seq[_]){
import sun.misc.Unsafe
val unsafe = { val fld = classOf[Unsafe].getDeclaredField("theUnsafe"); fld.setAccessible(true); fld.get(classOf[Unsafe]).asInstanceOf[Unsafe]; }
type char = Char
def WARN = assert(false, "WARN")
def ERROR = assert(false, "ERROR")
def apply(ARG: scala.collection.Seq[_]): scala.collection.Seq[_] = { object BODY {
  var RES = null.asInstanceOf[scala.collection.Seq[_]]
  val x0 = ARG
  val x1 = unsafe.allocateInstance(Class.forName("lancet.interpreter.TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$4"))
  val x6 = x0.asInstanceOf[Traversable[Object]].map { (x2:Object) => {
      var RES = null.asInstanceOf[Object]
      val x3 = x2.asInstanceOf[lancet.interpreter.TestInterpreter4$Person] // checkCast
      val x4 = unsafe.allocateInstance(Class.forName("lancet.interpreter.TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$4$$anon$1"))
      // unique method: HotSpotMethod<TestInterpreter4$Person.age> TODO: guard
      val x5 = unsafe.getInt(x3,16L)
      unsafe.putInt(x4,16L, x5)
      (RES = x4) // return to root
      // (no return?)
      RES.asInstanceOf[Boolean]
  }}
  val x7 = x6.asInstanceOf[scala.collection.TraversableLike[_,_]] // checkCast
  val x8 = x7.asInstanceOf[Object] // work around value classes, which aren't classes
  val x9 = unsafe.allocateInstance(Class.forName("lancet.interpreter.TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$5"))
  val x65 = x8.asInstanceOf[Traversable[Object]].map { (x10:Object) => {
      var RES = null.asInstanceOf[Object]
      val x11 = CONST_1.invoke(x10).asInstanceOf[Object] // java.lang.Object.getClass
      // WARNING: multiple returns (2) in HotSpotMethod<TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$5.reflMethod$Method1>
      ;{
        var vPHI_3_7 = null.asInstanceOf[Object]
        var vx0 = null.asInstanceOf[scala.collection.Seq[_]]
        var vx1 = null.asInstanceOf[Object]
        var vx10 = null.asInstanceOf[Object]
        var vx11 = null.asInstanceOf[Object]
        var vx12 = null.asInstanceOf[Object]
        var vx13 = null.asInstanceOf[Object]
        var vx14 = null.asInstanceOf[Boolean]
        var vx23 = null.asInstanceOf[Object]
        var vx24 = null.asInstanceOf[Boolean]
        var vx38 = null.asInstanceOf[Object]
        var vx39 = null.asInstanceOf[Boolean]
        var vx8 = null.asInstanceOf[Object]
        var vx9 = null.asInstanceOf[Object]
        val x12 = unsafe.getObject(Class.forName("lancet.interpreter.TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$5"),208L)
        // unique method: HotSpotMethod<SoftReference.get> TODO: guard
        val x13 = unsafe.getObject(x12,16L)
        val x14 = x13 eq null
        if (x14) {
          BLOCK_48(x0,x1,x10,x11,x12,x13,x14,x8,x9)
        } else {
          val x15 = unsafe.getLong(x12,48L)
          val x16 = unsafe.getLong(Class.forName("java.lang.ref.SoftReference"),200L)
          val x17 = x15 < x16
          val x20 = if (x17) {
            -1
          } else {
            val x18 = x15 == x16
            val x19 = if (x18) {
              0
            } else {
              1
            }
            x19
          }
          val x21 = x20 == 0
          if (x21) {
            BLOCK_48(x0,x1,x10,x11,x12,x13,x14,x8,x9)
          } else {
            /* cse: WrappedArray(unsafe.getLong(Class.forName("java.lang.ref.SoftReference"),200L)) = x16*/
            val x22 = x16.toDouble
            unsafe.putDouble(x12,48L, x22)
            ERROR // write to unknown: Top
            ;{
              BLOCK_48(x0,x1,x10,x11,x12,x13,x14,x8,x9)
            }
          }
        }
        def BLOCK_48(x0:scala.collection.Seq[_],x1:Object,x10:Object,x11:Object,x12:Object,x13:Object,x14:Boolean,x8:Object,x9:Object): Unit = {
          val x23 = x13.asInstanceOf[scala.runtime.MethodCache] // checkCast
          val x24 = x23 ne null
          if (x24) {
            BLOCK_67(x0,x1,x10,x11,x12,x13,x14,x23,x24,x8,x9)
          } else {
            val x25 = unsafe.allocateInstance(Class.forName("java.lang.ref.SoftReference"))
            val x26 = unsafe.allocateInstance(Class.forName("scala.runtime.EmptyMethodCache"))
            unsafe.putObject(x25,16L, x26)
            val x27 = unsafe.getObject(Class.forName("java.lang.ref.ReferenceQueue"),200L)
            unsafe.putObject(x25,24L, x27)
            val x28 = unsafe.getLong(Class.forName("java.lang.ref.SoftReference"),200L)
            val x29 = x28.toDouble
            unsafe.putDouble(x25,48L, x29)
            unsafe.putObject(Class.forName("lancet.interpreter.TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$5"),208L, x25)
            ;{
              BLOCK_67(x0,x1,x10,x11,x12,x13,x14,x23,x24,x8,x9)
            }
          }
        }
        def BLOCK_67(x0:scala.collection.Seq[_],x1:Object,x10:Object,x11:Object,x12:Object,x13:Object,x14:Boolean,x23:Object,x24:Boolean,x8:Object,x9:Object): Unit = {
          /* cse: WrappedArray(unsafe.getObject(Class.forName("lancet.interpreter.TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$5"),208L)) = x12*/
          // unique method: HotSpotMethod<SoftReference.get> TODO: guard
          /* cse: WrappedArray(unsafe.getObject(x12,16L)) = x13*/
          /* cse: WrappedArray(ObjectEqual(x13,null)) = x14*/
          if (x14) {
            BLOCK_73(x0,x1,x10,x11,x12,x13,x14,x23,x24,x8,x9)
          } else {
            val x30 = unsafe.getLong(x12,48L)
            val x31 = unsafe.getLong(Class.forName("java.lang.ref.SoftReference"),200L)
            val x32 = x30 < x31
            val x35 = if (x32) {
              -1
            } else {
              val x33 = x30 == x31
              val x34 = if (x33) {
                0
              } else {
                1
              }
              x34
            }
            val x36 = x35 == 0
            if (x36) {
              BLOCK_73(x0,x1,x10,x11,x12,x13,x14,x23,x24,x8,x9)
            } else {
              /* cse: WrappedArray(unsafe.getLong(Class.forName("java.lang.ref.SoftReference"),200L)) = x31*/
              val x37 = x31.toDouble
              unsafe.putDouble(x12,48L, x37)
              ERROR // write to unknown: Top
              ;{
                BLOCK_73(x0,x1,x10,x11,x12,x13,x14,x23,x24,x8,x9)
              }
            }
          }
          def BLOCK_73(x0:scala.collection.Seq[_],x1:Object,x10:Object,x11:Object,x12:Object,x13:Object,x14:Boolean,x23:Object,x24:Boolean,x8:Object,x9:Object): Unit = {
            /* cse: WrappedArray(x13, .asInstanceOf[scala.runtime.MethodCache] // checkCast) = x23*/
            val x38 = CONST_2.invoke(x23.asInstanceOf[AnyRef],x11.asInstanceOf[AnyRef]).asInstanceOf[Object] // scala.runtime.MethodCache.find
            val x39 = x38 ne null
            if (x39) {
              /*R_42_14_0;*/;{
                val PHI_3_7 = x38 // LUBC(x41:Object,x38:Object)
                vPHI_3_7 = PHI_3_7
                vx0 = x0
                vx1 = x1
                vx10 = x10
                vx11 = x11
                vx12 = x12
                vx13 = x13
                vx14 = x14
                vx23 = x23
                vx24 = x24
                vx38 = x38
                vx39 = x39
                vx8 = x8
                vx9 = x9
              };
            } else {
              val x40 = unsafe.getObject(Class.forName("lancet.interpreter.TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$5"),200L)
              val x41 = x11.asInstanceOf[Class[_]].getMethod("foo".asInstanceOf[String],x40.asInstanceOf[Class[_]])
              val x42 = CONST_3.invoke(x41).asInstanceOf[Boolean] // java.lang.reflect.AccessibleObject.isAccessible
              val x43 = if (x42) {
                1
              } else {
                0
              }
              val x44 = x43 != 0
              if (x44) {
                BLOCK_82(x0,x1,x10,x11,x12,x13,x14,x23,x24,x38,x39,x40,x41,x42,x44,x8,x9)
              } else {
                CONST_4.invoke(x41.asInstanceOf[AnyRef],true.asInstanceOf[AnyRef]).asInstanceOf[Unit] // java.lang.reflect.AccessibleObject.setAccessible
                ;{
                  BLOCK_82(x0,x1,x10,x11,x12,x13,x14,x23,x24,x38,x39,x40,x41,x42,x44,x8,x9)
                }
              }
              def BLOCK_82(x0:scala.collection.Seq[_],x1:Object,x10:Object,x11:Object,x12:Object,x13:Object,x14:Boolean,x23:Object,x24:Boolean,x38:Object,x39:Boolean,x40:Object,x41:Object,x42:Boolean,x44:Boolean,x8:Object,x9:Object): Unit = {
                val x45 = unsafe.allocateInstance(Class.forName("java.lang.ref.SoftReference"))
                /* cse: WrappedArray(unsafe.getObject(Class.forName("lancet.interpreter.TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$5"),208L)) = x12*/
                // unique method: HotSpotMethod<SoftReference.get> TODO: guard
                /* cse: WrappedArray(unsafe.getObject(x12,16L)) = x13*/
                /* cse: WrappedArray(ObjectEqual(x13,null)) = x14*/
                if (x14) {
                  BLOCK_89(x0,x1,x10,x11,x12,x13,x14,x23,x24,x38,x39,x40,x41,x42,x44,x45,x8,x9)
                } else {
                  val x46 = unsafe.getLong(x12,48L)
                  val x47 = unsafe.getLong(Class.forName("java.lang.ref.SoftReference"),200L)
                  val x48 = x46 < x47
                  val x51 = if (x48) {
                    -1
                  } else {
                    val x49 = x46 == x47
                    val x50 = if (x49) {
                      0
                    } else {
                      1
                    }
                    x50
                  }
                  val x52 = x51 == 0
                  if (x52) {
                    BLOCK_89(x0,x1,x10,x11,x12,x13,x14,x23,x24,x38,x39,x40,x41,x42,x44,x45,x8,x9)
                  } else {
                    /* cse: WrappedArray(unsafe.getLong(Class.forName("java.lang.ref.SoftReference"),200L)) = x47*/
                    val x53 = x47.toDouble
                    unsafe.putDouble(x12,48L, x53)
                    ERROR // write to unknown: Top
                    ;{
                      BLOCK_89(x0,x1,x10,x11,x12,x13,x14,x23,x24,x38,x39,x40,x41,x42,x44,x45,x8,x9)
                    }
                  }
                }
                def BLOCK_89(x0:scala.collection.Seq[_],x1:Object,x10:Object,x11:Object,x12:Object,x13:Object,x14:Boolean,x23:Object,x24:Boolean,x38:Object,x39:Boolean,x40:Object,x41:Object,x42:Boolean,x44:Boolean,x45:Object,x8:Object,x9:Object): Unit = {
                  /* cse: WrappedArray(x13, .asInstanceOf[scala.runtime.MethodCache] // checkCast) = x23*/
                  val x54 = CONST_5.invoke(x23.asInstanceOf[AnyRef],x11.asInstanceOf[AnyRef],x41.asInstanceOf[AnyRef]).asInstanceOf[Object] // scala.runtime.MethodCache.add
                  unsafe.putObject(x45,16L, x54)
                  val x55 = unsafe.getObject(Class.forName("java.lang.ref.ReferenceQueue"),200L)
                  unsafe.putObject(x45,24L, x55)
                  val x56 = unsafe.getLong(Class.forName("java.lang.ref.SoftReference"),200L)
                  val x57 = x56.toDouble
                  unsafe.putDouble(x45,48L, x57)
                  unsafe.putObject(Class.forName("lancet.interpreter.TestInterpreter4$$anonfun$test4$1$$anonfun$4$$anonfun$apply$5"),208L, x45)
                  /*R_42_13_0;*/;{
                    val PHI_3_7 = x41 // LUBC(x38:Object,x41:Object)
                    vPHI_3_7 = PHI_3_7
                    vx0 = x0
                    vx1 = x1
                    vx10 = x10
                    vx11 = x11
                    vx12 = x12
                    vx13 = x13
                    vx14 = x14
                    vx23 = x23
                    vx24 = x24
                    vx38 = x38
                    vx39 = x39
                    vx8 = x8
                    vx9 = x9
                  };
                }
              }
            }
          }
        }
        ;{
          val PHI_3_7 = vPHI_3_7
          val x0 = vx0
          val x1 = vx1
          val x10 = vx10
          val x11 = vx11
          val x12 = vx12
          val x13 = vx13
          val x14 = vx14
          val x23 = vx23
          val x24 = vx24
          val x38 = vx38
          val x39 = vx39
          val x8 = vx8
          val x9 = vx9
          val x58 = new Array[java.lang.Object](0)
          val x59 = PHI_3_7.asInstanceOf[java.lang.reflect.Method].invoke(x10,x58)
          val x60 = x59.asInstanceOf[java.lang.Integer] // checkCast
          val x61 = x60 ne null
          if (x61) {
            val x62 = x60.asInstanceOf[java.lang.Integer] // checkCast
            val x63 = unsafe.getInt(x62,16L)
            ;{
              val PHI_4_4 = x63 // LUBC(PHI_4_4:Int,x63:Int)
              BLOCK_109(PHI_4_4,x0,x1,x10,x11,x12,x13,x14,x23,x24,x38,x39,x58,x59,x60,x61,x8,x9)
            }
          } else {
            val PHI_4_4 = 0 // LUBC(PHI_4_4:Int,0:Int)
            BLOCK_109(PHI_4_4,x0,x1,x10,x11,x12,x13,x14,x23,x24,x38,x39,x58,x59,x60,x61,x8,x9)
          }
          def BLOCK_109(PHI_4_4:Int,x0:scala.collection.Seq[_],x1:Object,x10:Object,x11:Object,x12:Object,x13:Object,x14:Boolean,x23:Object,x24:Boolean,x38:Object,x39:Boolean,x58:Object,x59:Object,x60:Object,x61:Boolean,x8:Object,x9:Object): Unit = {
            val x64 = PHI_4_4.asInstanceOf[java.lang.Integer]
            (RES = x64) // return to root
          }
      }}
      // (no return?)
      RES.asInstanceOf[Boolean]
  }}
  val x66 = x65.asInstanceOf[scala.collection.Seq[_]] // checkCast
  (RES = x66) // return to root
  // (no return?)
}; BODY.RES }
}

compilation: ok
<decompiled>
