/*
 * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/agpl.html.
 * 
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package lancet
package analysis

class TestAnalysis8 extends FileDiffSuite {

  val prefix = "test-out/test-analysis-8"

// language interface
trait Intf {
  
  type Rep[T]
  type Var[T]
  
  implicit def unit[T](x:T): Rep[T]
  
  def plus(x: Rep[Int], y: Rep[Int]): Rep[Int]
    
  def newVar[T](nme: String, x:Rep[T]): Var[T]
  
  implicit def readVar[T](x: Var[T]): Rep[T]
  
  def writeVar[T](x: Var[T], v: Rep[T]): Rep[Unit]

  def whileNonZero(cond: => Rep[Int])(body: => Rep[Unit]): Rep[Unit]
  
  def program(x: => Rep[Unit]): Unit
  
}


// string implementation (just for completeness, not used)
trait ImplString extends Intf {
  
  var symCount = 0
  def fresh: String = { symCount += 1; (symCount - 1).toString }
  
  type Rep[T] = String
  type Var[T] = String
  
  implicit def unit[T](x:T): Rep[T] = x.toString
  
  def whileNonZero(cond: => Rep[Int])(body: => Rep[Unit]): Rep[Unit] = {
    println("while ({")
    println(cond)
    println("}) {")
    println(body)
    println("}")
    "()"
  }
  
  def newVar[T](nme: String, x: Rep[T]): Var[T] = {
    println("var " + nme + " = " + x)
    nme
  }
  
  implicit def readVar[T](x: Var[T]): Rep[T] = {
    val v = fresh
    println("val " + v + " = " + x)
    v
  }
  
  def writeVar[T](x: Var[T], y: Rep[T]): Rep[Unit] = {
    println(x + " = " + y)
    "()"
  }
 
  def plus(x: Rep[Int], y: Rep[Int]): Rep[Int] = {
    "(" + x + "+" + y + ")"
  }
  
  def program(x: => Rep[Unit]): Unit = {
    x
  }
  
  
}


// abstract interpretation impl
trait Impl extends Intf {
  
  // lattice of abstract values: bottom < { zero, neg, pos} < top
  abstract class Lattice
  case object Bottom extends Lattice
  case object Top extends Lattice
  case object Zero extends Lattice
  case object Neg extends Lattice
  case object Pos extends Lattice
  
  // lattice of abstract states: map var names to abstract values
  type State = Map[String,Lattice]
  
  // we maintain an abstract state in a mutable fashion
  // we could also thread the state explicitly or use a 
  // state monad encoding
  var state: State = _
  
  // lub calculations
  def varLub(a: Lattice, b: Lattice) = (a,b) match {
    case (Bottom, b) => b
    case (a, Bottom) => a
    case (a, b) if a == b => a
    case _ => Top
  }
  
  def stateLub(a: State, b: State) = {
    var m = a
    for ((k,v) <- b) {
      m += (k -> varLub(a getOrElse(k,Bottom), v))
    }
    m
  }

  // fix abstract value representation
  type Rep[T] = Lattice
  type Var[T] = String
  
  
  
  // operations on lattice elements

  def maybeNonZero(c: Lattice) = c match {
    case Zero | Bottom => false
    case _ => true
  }

  def maybeZero(c: Lattice) = c match {
    case Pos | Neg | Bottom => false
    case _ => true
  }


  implicit def unit[T](x:T): Rep[T] = x match {
    case 0 => Zero
    case x: Int => if (x > 0) Pos else Neg
    case _ => Top
  }
  
  def plus(x: Rep[Int], y: Rep[Int]): Rep[Int] = (x,y) match {
    case (Pos,Pos) => Pos
    case (Neg,Neg) => Neg
    case (Zero,Pos) => Pos
    case (Pos,Zero) => Pos
    case (Zero,Neg) => Neg
    case (Neg,Zero) => Neg
    case (Zero,Zero) => Zero
    case (Bottom,a) => a
    case (a,Bottom) => a
    case _ => Top
  }
  
  
  // conditionals will compute lub of states
  def ifNonZero(c: Rep[Int])(a: => Rep[Unit])(b: => Rep[Unit]): Rep[Unit] = {
    val st0 = state
    val sta = if (maybeNonZero(c)) { a; state } else Map():State
    state = st0 // reset state before executing else branch
    val stb = if (maybeZero(c)) { b; state } else Map():State
    state = stateLub(sta,stb)
  }

  // while loops will iterate until state converges
  def whileNonZero(cond: => Rep[Int])(body: => Rep[Unit]): Rep[Unit] = {

    val st0 = state
    
    // if we were to transform the code based on dataflow information,
    // we would save the output generated by the conditional and
    // print it only once we are converged, not if we iterate (see below).
    
    ifNonZero(cond) {
      body
    } {
    }
    
    val st2 = state
      
    if (st2 != st0) {
      println("while loop changed state from " + st0 + " to " + st2 + ", try again")
      whileNonZero(cond)(body)
    } else {
      println("while loop has converged to state " + st2)
    }
  }
  
  def newVar[T](x: String, y: Rep[T]): Var[T] = {
    println("var " + x + " = " + y)
    state += (x -> y)
    x
  }
  
  implicit def readVar[T](x: Var[T]): Rep[T] = {
    state(x)
  }
  
  def writeVar[T](x: Var[T], y: Rep[T]): Rep[Unit] = {
    println(x + " = " + y)
    state += (x -> y)
    Top
  }
 
  def program(body: => Rep[Unit]): Unit = {
    state = Map()
    body
    println("--- state after program: " + state)
  }
  
  
}



// test program

trait AbsIntProg1 extends Intf {

  program {
    val c = newVar("c", 0)
    whileNonZero(c) {
      writeVar(c, plus(c,1))
    }
    // infer c is zero here
  }

  program {
    val c = newVar("c", 0)
    whileNonZero(1) {
      writeVar(c, plus(c,1))
    }
    // infer c is positive here
  }

  program {
    val c = newVar("c", 1)
    whileNonZero(c) {
      writeVar(c, plus(c,-1))
    }
    // infer c is top -- cannot reason backwards from condition to environment that c must be zero
  }


  program {
    val c = newVar("c", 1)
    whileNonZero(c) {
      writeVar(c, plus(c,-1))
    }
    // c = top
    val x = newVar("x", 0)
    whileNonZero(c) {
      writeVar(x, 1)
    }
    // x = top, since we don't know whether the loop executes
  }


  println("done")  
}


// runner

def test1 = withOutFileChecked(prefix+"A") {
  new AbsIntProg1 with Impl
}


}
